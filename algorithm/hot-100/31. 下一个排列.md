# 31. 下一个排列

## 题目

难度: 中等

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

* 例如，`arr=[1,2,3]`，以下这些都可以视作 arr 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]`。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

* 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]`。
* 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]`。
* 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]`，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 nums，找出 nums 的下一个排列。

必须**原地**修改，只允许使用额外常数空间。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]

```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]

```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]

```

> 来源: 力扣（LeetCode）  
> 链接: <https://leetcode.cn/problems/next-permutation/?favorite=2cktkvj>  
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 答案

### 1. 方法一：两遍扫描

原理：

* 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列
* 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小

以 `[4,5,2,6,3,1]` 举例：

* 找到较小数 2 和较大数 3，满足较小数尽可能靠右而较大数尽可能小
* 当我们完成交换后排列变为 `4,5,3,6,2,1]`，此时我们可以重排「较小数」右边的序列，序列变为 `[4,5,3,1,2,6]`

算法描述：

* 首先从后向前查找第一个顺序对 `(i,i+1)`，满足 `a[i] < a[i+1]`。这样「较小数」即为 `a[i]`。此时 `[i+1,n)` 必然是下降序列。
* 如果找到了顺序对，那么在区间 `[i+1,n)` 中从后向前查找第一个元素 `j` 满足 `a[i]< a[j]`。这样「较大数」即为 `a[j]`。
* 交换 `a[i]` 与 `a[j]`，此时可以证明区间 `[i+1,n)` 必为降序。我们可以直接使用双指针反转区间 `[i+1,n)` 使其变为升序，而无需对该区间进行排序。
* 如果在步骤 1 找不到顺序对，说明当前序列已经是一个降序序列，即最大的序列，我们直接跳过步骤 2 执行步骤 3，即可得到最小的升序序列。

> 该方法支持序列中存在重复元素，且在 C++ 的标准库函数 [`next_permutation`](https://en.cppreference.com/w/cpp/algorithm/next_permutation) 中被采用。

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        // 处理特殊情况
        if (nums.size() <= 1) {
            return;
        }

        // 从右到左找到第一个开始递减的数, 下标赋值给i
        int i = nums.size() - 2;
        while (i >= 0) {
            if (nums[i] < nums[i+1]) {
                break;
            }
            --i;
        }

        // 如果i < 0则跳过这一步(意味着此时是最大的数)：
        // 1) 在较小数的右边, 即(i, n-1]中找到尽量小的较大数
        // 2)　交换较大数和较小数
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0) {
                if (nums[j] > nums[i]) {
                    break;
                }
                j--;
            }

            // 交换较大数和较小数
            std::swap(nums[i], nums[j]);
        }

        // 利用双指针法升序重排[i+1, nums.size() - 1]
        // 注意此时[i+1, nums.size() - 1]区间必为降序
        int left = i + 1;
        int right = nums.size() - 1;
        while (left < right) {
            std::swap(nums[left], nums[right]);
            ++left;
            --right;
        }

        return;
    }
};

```

## Reference

[1] <https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/>
