# 1588. 所有奇数长度子数组的和

## 题目

难度: 简单

给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。

**子数组** 定义为原数组中的一个连续子序列。

请你返回 arr 中 **所有奇数长度子数组的和** 。

**示例 1：**

```
输入：arr = [1,4,2,5,3]
输出：58
解释：所有奇数长度子数组和它们的和为：
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
```

**示例 2：**

```
输入：arr = [1,2]
输出：3
解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
```

**示例 3：**

```
输入：arr = [10,11,12]
输出：66

```

> 来源: 力扣（LeetCode）  
> 链接: <https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/>  
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 思路

题目要求的是奇数长度的子数组，那么，我们可以不失一般性地考虑，原数组中的每个数一共会出现在多少个奇数子数组中，也就是这个数一共会出现多少次，这样的话，我们把所有元素遍历一遍，找到每个数出现的次数，相乘再相加就得到结果了。

比如，以 arr = [1,4,2,5,3]为例，假设我们现在要看 2 这个元素在哪些子数组中会出现，我们可以先试着画出下面这张图：

![image-20210829154918199](image/1630224906-EQwqsA-file_1630224905967)

明显地，在包含 2 的所有子数组中，从 2 的位置分成两半，它左边的部分和它右边的部分必须同时为偶数或者奇数，才能组成奇数长度的子数组。

这也很好理解，相当于从一个奇数子数组中去掉 2 这个数，那剩下的数肯定是偶数，而这些数不是在 2 的右边，就是在 2 的左边，一个偶数分两半，那肯定是同偶或者同奇的。

OK，这样的话，我们只要算出一个数 左边可能为奇数的数量 与 右边可能为奇数的数量、左边可能为偶数的数量与右边可能为偶数的数量，两两相乘再相加就是这个数可能出现的所有奇数子数组的数量，再乘以这个数本身，就是这个数对结果的贡献。

比如，还是上面的例子，2 的左边可能为奇数的数量只有 1个，同样地，右边也是 1，1 *1 = 1，所以 2 两边同奇的可能性只有 1；2的左边可能为偶数的数量为 0 或 2 两种可能，右边也是 0 或 2 两种可能，2* 2 = 4，所以，2 的两边同偶的可能性有 4 种。奇偶两种情况一共是 5 种，再乘以 2 本身等于 10，就是对结果的贡献。

## 答案

```c++
class Solution {
public:
    int sumOddLengthSubarrays(vector<int>& arr) {
        int ans = 0;
        int n = arr.size();
        
        for (int i = 0; i < arr.size(); i++) {
            // 左边奇数个数的可能性
            int left_odd = (i + 1) / 2;
            // 右边奇数个数的可能性
            int right_odd = (n - i) / 2;
            // 左边偶数个数的可能性
            int left_even = i / 2 + 1;
            // 右边偶数个数的可能性
            int right_even = (n - i - 1) / 2 + 1;
            // 计算结果
            ans += arr[i] * (left_odd * right_odd + left_even * right_even);
        }

        return ans;
    }
};
```
