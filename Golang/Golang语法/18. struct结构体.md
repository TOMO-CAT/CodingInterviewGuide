# struct 结构体

## 可见性（包级别的可见性）

要使某个符号对其他包 `package` 可见，需要将该符号（结构体内的数据成员或者方法成员的名称）定义为以大写字母开头。

需要注意的是，Go 语言中符号的可见性是包一级而不是类型一级的。**尽管一个结构体的方法成员的符号是小写的，但同一个包的其他类型也可以访问到它。**这样的可访问性控制很粗糙，但是非常实用。因为如果 Go 语言符号的可访问性是类型一级的，少不了还要加上 `friend` 这样的关键字，以表示两个类是朋友关系，可以访问彼此的私有成员。

## 初始化

在 Go 语言中未进行显式初始化的变量都会被初始化为该类型的零值，例如 `bool` 类型零值时 `false`，`int` 类型零值是 0，`string` 类型的零值是空字符串。

Go 语言中不存在构造函数的概念，对象的创建通常交给一个全局的 `NewXXX()` 函数来完成：

```go
func NewRect(width, height float64) *Rect {
    retutn &Rect{width, height}
}
```

## 方法中对象的参数传递方式

### 1. 指针传递（小对象时用指针传递可能还是一个损耗，要修改对象必须用指针传递）

前面我们定义了成员方法，其中 `Area` 是方法名，`Rect` 是方法的接收者，`r` 表示对应的 `Rect` 实例，`*` 号表示方法中对象的参数传递方式是指针传递：

```go
// 指针传递对象
func (r *Rect) Area() float64 {
    return r.width * r.height
}
```

如果需要修改对象必须以指针传递，这有时候会是一个额外成本，因为对象有时很小（比如 4 字节），这时候用指针传递并不划算。

> 只有在你需要修改对象时，才必须使用指针。

### 2. 值传递

```go
// 值传递对象
func (r Rect) Area() float64 {
    return r.width * r.height
}
```

### 3. 总结

* 当你需要在方法内部修改对象时必须以指针传递
* 当结构体较大时，指针传递可以提升性能
* 当对象较小时（比如 4 字节），使用值传递可以提升性能
* **为了保持代码一致性，建议统一使用指针传递**，同时也可以避免出现 bug
