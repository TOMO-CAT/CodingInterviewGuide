# 复制数组与复制切片

## 数组

数组是一系列同一类型数据的集合，常用的声明方法如下：

```go
[32]byte          // 长度为 32 的字节数组
[3][5]int         // 3 行 5 列的二维数组
[2][2][2]float64  // 等价于[2]([2]([2]float64))
```

在 Go 语言中，数组长度在定义后就不可更改，在声明时长度可以为一个常量或者一个常量表达式（常量表达式指的是在编译器即可计算结果的表达式）。

## 数组是值类型

在 Go 语言中数组是一个值类型 `value type`（所有的值类型遍历在赋值和作为参数传递时都将产生一次复制动作）。

如果将数组作为函数的参数类型，则在函数调用时该数组参数将发生数据复制。因此在函数体重无法修改传入的数组的内容，因为函数内操作的只是传入数组的一个副本。

## 数组切片底层实现

数组切片有点像是数组的指针，但实际上它拥有自己的数组结构而并非仅仅是一个指针。数组切片的数据结构可以抽象为如下 3 个变量：

* 一个指向原生数组的指针
* 数组切片中的元素个数
* 数组切片已分配的存储空间

```go
type SliceHeader struct {
 Data uintptr  // 引用数组指针地址
 Len  int      // 切片的目前使用长度
 Cap  int      // 切片的容量
}
```

## 合理设置 capacity 提高切片性能

> 与数组相比，数组切片多了一个容量 `capacity` 的概念，即元素个数和分配的空间可以是不同的两个值。合理设置存储能力的值可以大幅降低数组切片内部重新分配内存和拷贝内存块的频率，从而大大提高程序性能。

假设我们明确知道数组切片的最大存储元素个数为 100，那么最好在创建数组切片时设置 `capacity` 为 100。（假设你设置 `capacity` 为 30，那么当元素个数超过 30 个时底层会发生至少一次重新分配更大的内存并将切片内容从原来的内存块拷贝到新的内存块的动作，这会导致明显的 CPU 开销）

* `len(mySlice)`：返回数组切片当前元素个数
* `cap(mySlice)`：返回数组切片分配空间的大小
