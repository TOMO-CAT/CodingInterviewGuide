# 最多能创建多少个 TCP 连接

## 总结

每个 TCP 连接需要如下资源：

![图片](image/640-164766868483220.png)

| 资源        | Linux 服务器提供的资源 | 单个 TCP 连接占用的资源   | 占满后会发生什么                |
| ----------- | --------------------- | ----------------------- | ------------------------------- |
| 临时端口号  | ip_local_port_range   | 1                       | cannot assign requested address |
| 文件描述符  | fs.file-max           | 1                       | too many open files             |
| 进程/线程数 | ulimit -n             | 取决于 IO 模型            | 系统崩溃                        |
| 内存        |                       | 取决于缓冲区大小        | OOM                             |
| CPU         |                       | 取决于 TCP 连接的工作内容 | 电脑卡死                        |

## socket 四元组与文件描述符

Linux 上的进程向操作系统申请创建 TCP 连接时，需要提供 socket 四元组：

![图片](image/640.jpeg)

假设我们只有一块网卡（IP 地址是 **123.126.45.68**），假如我们要和

**110.242.68.3** 的 80 端口建立一个 TCP 连接，那么我们建立的 socket 四元组如下：

![图片](image/640-16476648210162.jpeg)

端口号是 16 位的（1~65535），操作系统会自动为我们分配可用的数字。

操作系统建立完 TCP 连接后会返回一个文件描述符（Linux 下一切皆文件），我们和目标 IP 进行 TCP 连接时对这个文件描述符进行读写即可。

## 端口号限制

前面提到端口号是 16 位的，取值范围是 1~65535。

根据 socket 四元组，假设我们固定住源 IP、目标 IP 和目标端口，那么理论上我们可以建立的 TCP 连接就是 65535 个。

我们不停地向操作系统申请建立 TCP 连接，创建了 63977 后操作系统抛出错误：

![图片](image/640-16476654759744.jpeg)

该错误表示无法分配新的端口，那为什么理论上能创建 65535 个 TCP 连接而我们只创建了 63977 个 TCP 连接就不够用了呢？

原因在于 Linux 对可使用地端口范围是有限制的，可以根据如下命令查看：

```bash
$cat /proc/sys/net/ipv4/ip_local_port_range 
1024 65000
```

可以看到当前限制是 1024~65000，共计 63977 个端口可以使用。

![图片](image/640-16476658405716.png)

我们修改 `/etc/sysctl.conf` 这个文件来改变可分配的端口号范围，例如我们通过 vim 在这个文件中增加一行：

```bash
net.ipv4.ip_local_port_range = 60000 60009
```

保存好后执行如下命令生效：

```bash
$sysctl -p /etc/sysctl.conf
```

此时你就只有 10 个端口号可用，会更快报出端口号不足的错误。

## 文件描述符限制

理论上建立一个 TCP 连接需要将通信两端的套接字（socket）进行绑定：

![image-20220319130254721](image/image-20220319130254721.png)

因此如果我们更改四元组中其他三个元素就可以突破端口号不足的限制创建新的 TCP 连接。举个例子，我们更换一下目标端口（从 80 改成 3306）就可以继续建立 TCP 连接：

![图片](image/640-16476669054408.jpeg)

我们继续不停地建立 TCP 连接，直到操作系统抛出错误：

![图片](image/640-164766707962210.jpeg)

这个错误指的是文件描述符不够用。原因在于每建立一个 TCP 连接操作系统就需要分配给进程一个文件描述符，Linux 对可打开的文件描述符数量做了三个方面的限制：

* **系统级**：当前系统可打开的最大数量，通过 `cat /proc/sys/fs/file-max` 查看
* **用户级**：指定用户可打开的最大数量，通过 `cat /etc/security/limits.conf` 查看
* **进程级**：单个进程可打开的最大数量，通过 `cat /proc/sys/fs/nr_open` 查看

![图片](image/640-164766724703612.png)

```bash
[root ~]# cat /proc/sys/fs/file-max
100000
[root ~]# cat /proc/sys/fs/nr_open
100000
[root ~]# cat /etc/security/limits.conf
...
* soft nproc 100000
* hard nproc 100000
```

回忆一下我们最后一次创建 TCP 连接成功后收到的文件描述符就是 100000，再之后就收到文件描述符不够的错误了。

我们可以通过命令修改单个进程可打开的最大文件描述符限制，例如限制单个进程可打开的最大文件描述符位 100：

```bash
echo 100 > /proc/sys/fs/nr_open
```

## 线程限制

我们通过修改配置将各种文件描述限制都扩大了十倍，继续肆无忌惮地建立新的 TCP 连接。但是慢慢发现操作系统建立一个 TCP 连接花的时间越来越久。

这是因为每建立一个 TCP 连接都需要消耗一个线程，操作系统一致再为这好几十万个线程不停地进行上下文切换：

![图片](image/640-164766790335414.png)

> C10K 问题：当服务器连接达到 1 万且每个连接都需要消耗一个线程资源时，操作系统就会不停地忙于线程地上下文切换，最终导致服务崩溃。

这种每创建一个 TCP 连接就创建一个线程的方式是最传统的多线程并发模型，早期的操作系统也只支持这种方式。但现在的操作系统支持 IO 多路复用的方式，即一个线程可以管理多个 TCP 连接的资源，这样操作系统就可以用少量的线程来管理大量的 TCP 连接了。

## 内存限制

将原来的 TCP 连接删除，并且把代码改成 IO 多路复用（一个线程管理多个 TCP 连接）的模型后，我们继续不停地创建 TCP 连接。直到操作系统抛出错误：

![图片](image/640-164766844041316.jpeg)

这个错误意味着内存溢出，原因在于每个 TCP 连接及其用到的缓冲区都需要占用一定内存，当内存不足时就会抛出该错误。

![图片](image/640-164766851408818.png)

## CPU 限制

我们给机器配置了足够多的内存，继续不停地创建 TCP 连接。很快 CPU 占用率就飙升到将近 100%。此时用户几乎什么事情都做不了，即使是鼠标动一下都需要很久才能响应。

## Reference

[1] <https://mp.weixin.qq.com/s/X6c_H5_4OInR8nFQVn7IMA>
