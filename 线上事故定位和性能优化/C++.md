# C++

## 死锁

### 1. 线程池饥饿死锁

**原因：**父任务和子任务使用同一个线程池，而且线程池使用率达到100%。父任务调用了`Wait()`方法等待子任务完成，但是父任务占用了线程池所有线程，导致子任务无法获得线程执行任务。

**解决方法**：

* 线程池使用率较高时自动扩容
* 父子任务不应该使用同一个线程池

### 2. C++重入malloc导致服务死锁

**现象**：调小线程数时有时候crash有时候hang住。

**调试**：使用gdb调试运行中的程序（gdb attach pid命令），大部分线程卡在了`pthread_cond_wait()`（这是线程池队列在等待任务），一部分卡在了`pthread_once()`

> 查看不同线程的堆栈信息，发现：
>
> * 很多线程因为访问非法内存触发了信号11，线程转而去处理这个信号。
> * 信号处理函数是使用`traceback()`打印堆栈然后调用`exit()`退出
> * 如果函数能正常调用`exit()`就是coredump，如果执行`traceback()`卡住了就是服务hang住
>
>

**原因**：`traceback()`调用了`malloc()`，如果线程在调用`malloc`时收到了信号11，就有可能重入`malloc`导致死锁。

**复现**：使用gdb设置断点，使得主线程在执行`malloc()`时发送SIGSEVG11信号，让其转而执行信号处理函数，完成`malloc()->...malloc()`的重入调用链。可以发现主线程卡在了`__lll_lock_wait_private()`而子线程卡在了`pthread_once()`。

## Crash

### 1. 普遍场景

异步线程访问了已经析构的变量。

### 2. 可变参数

`printf`有一个格式控制符，但是有两个参数。

### 3. std::sort传入非严格弱序比较器对象

在`vector`元素大于16时会使用快排，此时快排partition阶段从`<`改成`<=`会导致数组越界。

## 性能优化

### 1. 工具

* top命令
* perf进行采样看哪个函数占用CPU
* 注意IPC（每个时钟周期内可以完成的CPU指令）比%CPU更能反映CPU性能

### 2. 大结构体拷贝

解决：禁止拷贝或者使用引用

### 3. sync_fetch_and_add

底层也使用了锁只是粒度更小，测试性能时发现IPC显著降低

### 4. 字符使用clear好于直接赋值""

减少内存分配。

### 5. Json库调研

使用RapidJson加快司乘特征反序列化。

## 内存泄漏

### 1. STL未clear导致的内存增长

thrift服务中使用了一个全局上下文Context，里面包含一个map在每次thrift请求进来时都会往map里push内容。如果没有在thrift请求结束时clear掉本次的内容，就会导致map无限膨胀，从而内存不断增加。

```c++
class Context {
 private:
    std::map<long, int> MyMap;
}
```

## 编译问题

### 1. 编译的动态库顺序

在给编译器输入源文件，目标文件或者动态库静态库文件时，如果B文件依赖A文件中的内容，那么B文件应该放在A文件的**左边**。这个问题很隐蔽，而且莫名其妙，权且当个结论记住吧。
