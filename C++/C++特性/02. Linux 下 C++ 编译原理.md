# Linux 下 C++编译链接原理

## 编译链接的四个步骤

程序员编写完代码后，编译工具 GCC 将 C++ 等高级语言“翻译”成低级语言（汇编语言甚至是机器码），进而形成可执行文件。`gcc`指令编译`.cpp`文件主要包含四个流程：预处理`Preprocessing`、编译`Compilation`、汇编`Assembly`和链接`Linking`。

## g++和 gcc 指令的区别

* `gcc`是 GCC 编译器的通用编译指令，可以根据文件后缀名自动推断出编译语言类型；而`g++`无论目标文件的后缀是什么都会以编译 C++ 的方式编译目标文件
* 由于 C++ 的标准语法相当于 C 语言更加严格，因此对于不兼容 C++ 标准语法`.c`文件而言，使用`g++`可能编译无法通过
* 如果在`.cpp`文件中使用了 C++ 标准库，那么`g++`在编译 C++ 程序时可以轻松通过，但是`gcc`指令必须手动添加`-lstdc++ -shared-libgcc`等指令表明链接对应的 C++ 标准库

> 简单理解，`g++`和`gcc`都是 GCC 的调用指令，其中`g++`等同于`gcc -xc++ -lstdc++ -shared-libgcc`。我们最好使用`gcc`编译 C 程序，使用`g++`编译 C++程序。

## 预处理的内容包括哪些

预处理主要包含如下几步：

* 展开头文件
* 宏替换
* 去掉注释
* 条件编译

## #include 使用尖括号和双引号的区别

在 C++ 中调用一个函数之前必须先有函数的声明，因此我们将各种要调用的函数声明打包成头文件，在`.cpp`文件的开头`#include`该头文件就可以保证声明置于调用之前。举个例子，C++ 中`#include "foo.h"`语句的含义是在预处理阶段用`foo.h`文件的内容插入到这条语句的位置。

> C++ 中包含头文件可以写成`#include <foo.h>`或者`#include "foo.h"`，这两者表示编译器搜索头文件的顺序不同：
>
> * `<foo.h>`表示从系统目录下开始搜索，再搜索`$PATH`环境变量的目录，不搜索当前目录
> * `"foo.h"`表示从当前目录开始搜索，然后是系统目录和`$PATH`环境变量的目录
>
> 如果我们知道文件不在当前目录下的话，可以通过`<foo.h>`来加快搜索速度。

## 解释一下链接

到目前为止，我们将每个`.cpp`源文件都编译成一个`.o`二进制目标文件，但是这些文件并不能被执行（因为某个源文件生成的`.o`文件中可能引用了另一个`.o`文件或者某个库文件的符号，比如变量或者函数调用等）。

链接是编译的最后一步，会将前面编译好的`.o`文件、系统库的`.o`文件和库文件彼此相连接，把某个目标文件中引用的符号同另一个文件中的定义链接起来，将所有编译好的单元组成一个可执行文件。

> 由于前面编译单元都是单个`.cpp`文件，因此直到链接阶段才能检查全局空间是否存在**重复定义或者缺失定义**的问题。这也是为什么我们一般不在头文件中出现定义的原因，因为头文件可能被多个源文件包含，每个源文件单独编译后就会在全局空间出现多个定义。
>
> 注意：C++ 内 const 默认为内部连接（C 中 const 默认外部链接）。当 C 语言两个文件中都有`const int a`编译器会报重复定义的错误，而在 C++ 中不会。如果想让 C++ 中的 const 具有外部连接，必须显示声明为：
>
> ```c++
> extern const int a = 10;
> ```

### 1. 动态链接

动态链接在编译链接时并不会把库文件的代码加到可执行文件中，而是在运行时加载所需要的动态库。动态链接生成的程序往往占用空间更小，但是系统环境缺少所需的动态库则无法运行。动态库文件一般后缀名为`.so`。

### 2, 静态链接

与动态链接相反，静态链接在编译链接阶段就将库文件的所有代码加到可执行文件中，因此生成的程序体积更大，其后缀名一般为`.a`。
