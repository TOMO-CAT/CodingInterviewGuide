# RAII

## 背景：资源管理问题

操作系统的资源是有限的，当我们使用完资源后必须将该资源归还操作系统，因此使用资源的步骤包括：

* 获取资源
* 使用资源
* 释放资源

### 1. 堆内存

```c++
void foo() {
    int *pBuf = new int[256];
    if (!condition1) {
        return;  // 提前 return 存在内存泄漏风险
    }
    if (!condition2) {
        bar();   // bar()抛出异常时可能导致资源未及时释放
    }
    delete []pBuf;
}
```

### 2. 文件句柄

```c++
void foo() {
    FILE *pf = open("a.txt", "w");
    // 写文件
    fclose(pf);
}
```

### 3. 互斥量

```c++
void foo(void) {
    static std::mutex m;
    m.lock();
    // 业务逻辑
    m.unlock();
}
```

可以看到上述三种使用场景都遵循了获取-使用-释放的资源使用顺序，在使用资源过程中可能存在某个分支提前返回或者调用某个函数产生异常并抛出时导致资源未及时释放。

## 解决方案

对于上述三种情况，C++ 标准库提供了对应的解决方案，它们无一例外都是使用类来管理资源的：

* 内存管理使用智能指针：`std::unique_ptr`和`std::shared_ptr`
* 文件句柄管理使用文件流对象：`ifstream`、`ofstream`和`fstream`
* 互斥量管理：`std::lock_guard`、`std::unique_guard`和`std::shared_guard`

当离开作用域或者异常抛出时，栈上的对象会自动析构。对于上述实例，我们基于 RAII 的原则通过类来管理资源，并在栈上创建其对象，这样类构造的时候便会自动获取资源，而析构的时候会自动释放资源。

## RAII

### 1. 原理

RAII 全称是 Resource Acquisition Is Initialization，翻译为“资源获取就是初始化”，是 C++ 语言中的一种避免内存泄漏的最佳资源管理方法。由于 C++ 的语言机制保证了当一个对象创建时自动调用构造函数，当对象超出作用域时自动调用析构函数，RAII 要求我们使用类来管理资源，将资源与对象的生命周期绑定在一起（构造函数获取资源而析构函数释放资源）。

> 这里提到的系统资源指的都是受限资源，包括堆内存、文件句柄、线程、数据库链接、网络链接和互斥锁等，这些资源的数量不是无限的（甚至是独一份的），因此我们在使用资源后必须释放资源。

RAII 进行资源管理的步骤是：

* 构造一个资源管理类
* 在构造函数中获取资源
* 在析构函数中释放资源
* 在栈上创建类对象
* 离开作用域或异常抛出时，当前栈回溯从而析构对象释放资源

### 2. 与 GC 区别

和垃圾回收 GC 不同的是，RAII 可管理广义的资源，而 GC 算法只关心内存泄漏。不关心诸如文件句柄、互斥量等一些系统资源的泄漏问题。

## Reference

[1] <https://blog.csdn.net/quinta_2018_01_09/article/details/93638251>

[2] <https://www.cnblogs.com/jiangbin/p/6986511.html>

[3] <https://www.jianshu.com/p/3edd59f05174>
