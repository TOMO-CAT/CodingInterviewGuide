# 对象是否可被拷贝

## 问题

对象是否需要实现拷贝赋值运算符和拷贝构造函数？

## 解析

### 1. 是否需要实现拷贝的决定因素

**对象是否可被拷贝，与它本身是「值语义」还是「引用语义」相关。**

* **值语义**：关心对象表示的值。例如`std::string`虽然使用了 RAII，但其对象本身是值语义的，所以允许复制。
* **引用语义**：关心对象本身。复制一个具有引用语义的对象通常是没有意义的。例如`std::thread`表示一个线程，复制这个对象的话理论上需要创建一个完全相同的线程才行，所以不允许复制。

「值语义」和「引用语义」只能决定理论上是否可被复制的问题，**实际开发中如果不清楚某个类是否应该可被复制，默认把它写成不可复制，必要时才让它可复制**。

### 2. RAII 类与是否可复制

先说结论：对象是否可复制与它是否是 RAII 并无关系，例如`std::vector`和`std::thread`都是 RAII 类，但前者可复制而后者不可复制。

RAII 类通常是用来管理资源的，而资源管理从概念上讲是独占的。这是由于资源本身的特殊性造成的，资源一般来说是一个句柄（或者说指针），它的生命周期由它的管理者所决定。当多个管理者管理同一个资源时，相互之间就必须要进行一些协调工作。

RAII 类是否可复制依然取决于它是「值语义」还是「引用语义」：

* 「值语义」RAII 类：例如`std::vector`、`std::string`、`std::map`等，它们对于资源是独占的，因此**通过深拷贝实现拷贝构造函数和拷贝赋值运算符**，每个对象都管理自己独有的资源互不干扰。
* 「引用语义」RAII 类：它们具有共享的资源管理能力，因此一般禁止拷贝或者通过`std::shared_ptr`管理底层资源。

> 对于「引用语义」RAII 类而言，`std::shared_ptr<RAII_object>`要比`RAII_object`类内嵌`std::shared_ptr`更好。

以动态内存资源 RAII 类为例，它会在构造函数中申请内存，在析构函数中释放内存，如果用浅拷贝实现拷贝构造函数和拷贝赋值运算符，就可能出现 double-free 的问题。

## Reference

[1] <https://www.zhihu.com/question/21137420>
