# 右值引用

## 简介

> 编码规范：**只有在定义移动构造函数与移动赋值操作时使用右值引用，不要使用`std::forward`功能函数**，你可能会使用`std::move`来表示将值从一个对象移动而不是复制到另一个对象。

**右值引用指的是必须绑定到右值的引用**，我们可以通过`&&`来获取右值引用。

右值引用一个重要的性质就是只能绑定到一个将要销毁的对象，因此我们可以自由地将s一个右值引用的资源“移动”到另一个对象中去。

> Tips：正常来说左值引用只能绑定到左值上，右值引用只能绑定到右值上，但是我们可以将一个`const`的左值引用绑定到一个右值上。

```c++
int i = 42;
int &r = i;              // 正确: 左值引用
int &&rr = i;            // 错误: 不能将一个右值引用绑定到一个左值上
int &r2 = i * 42;        // 错误: 不能讲一个左值引用绑定到一个右值上
const int &r3 = i * 42;  // 正确: 我们可以将一个const的左值引用绑定到右值上
int &&rr2 = i * 42;      // 正确: 右值引用

```

需要注意的是我们不能将一个右值引用绑定到一个右值引用类型的变量上：

```c++
// 正确: 字面常量是右值, 可以被右值引用
int &&rr1 = 42;
// 错误: 变量是左值, 我们不能讲一个右值引用绑定到一个变量上, 即使这个变量是右值引用类型也不行
int &&rr2 = rr1; 
```

## 标准库move函数获得右值引用

虽然我们不能将一个右值引用直接绑定到左值上，但我们可以使用`utility`头文件中的`std::move`函数来获得绑定到左值上的右值引用：

```c++
int &&rr1 = 42;
int &&rr2 = std::move(rr1);
```

- 使用`move`的代码应该明确使用`std::move`而不是在提供`using`声明后使用`move`函数，防止和用户程序定义的接受单一形参的`move`函数冲突
- ==调用`std::move`就意味着承诺除了对原来的左值对象赋值或销毁它外，我们将不再使用这个对象的值==

## 接受右值引用参数的成员函数

了构造函数和赋值运算符外，一个成员函数也可以同时提供拷贝和移动版本（一个版本接受指向`const`的左值引用，一个版本指向非`const`的右值引用）：

```c++
// 定义push_back的标准库容器提供两个版本: 右值引用参数和const左值引用参数
void push_back(const T&);  // 拷贝: 绑定到任意类型的T
void push_back(T&&);       // 移动: 只能绑定到类型T的可修改的右值
```

> Tips：一般情况下我们不需要为函数定义接受一个`const T&&`或是一个普通的`T&`参数的版本。因为当我们希望从实参“窃取”数据时，通常传一个右值引用参数且该实参不能是`const`的，当我们希望从一个对象拷贝数据时，通常不需要定义一个接受普通`T&`参数的版本。
