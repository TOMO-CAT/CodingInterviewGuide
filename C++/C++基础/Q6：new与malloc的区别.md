# new 与 malloc 的区别

## new 与 delete

### 1. 简介

C++ 中动态内存的管理是通过 new 和 delete 这对运算符来实现的：

* new：在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化
* delete：接受一个动态对象的指针，销毁该对象并释放与之关联的动态内存

### 2. 工作机制

当我们使用一条 new 表达式时，实际上他执行了三步：

```c++
// 分配并初始化一个 string 对象
string *sp = new string("tomocat");
// 分配 10 个默认初始化的 string 对象
string *arr = new string[10];
```

* new 表达式调用一个名为 `operator new`（或者 `operator new[]`）的标准库函数，该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或对象的数组）
* 编译器运行相应的构造函数以构造这些对象，并为其传入初始值
* 对象被分配了空间并构造完成，返回一个指向该对象的指针

当我们使用一条 delete 表达式删除一个动态分配的对象时，实际上执行了两步操作：

```c++
// 销毁*sp, 然后释放 sp 指向的内存空间
delete sp;

// 销毁数组中的元素, 然后释放对应的内存空间
delete [] arr;
```

* 对 sp 所指的对象或者 arr 所指的数组中的元素执行相应的析构函数
* 编译器调用名为 `operator delete`（或者 `operator delete[]`）的标准库函数释放内存空间

### 3. new/delete 表达式 与 operator new/delete 函数

标准库 `operator new` 和 `operator delete` 并没有重载 new 表达式或者 delete 表达式，实际上我们根本无法自定义 new 表达式和 delete 表达式的行为：

* 一条 new 表达式总是先调用 `operator new` 函数以获取内存空间，然后在得到的内存空间中构造对象
* 一条 delete 表达式总是先销毁对象，然后调用 `operator delete` 函数释放对象所占用的内存

我们可以重载 `operator new` 和 `operator delete`函数，这样做的意义在于改变内存分配的方式。下面给出了重载这两个函数的一种简单方式：

```c++
void *operator new(size_t size) {
    if (void *mem = malloc(size))
        return mem;
    else
        throw bad_alloc();
}
void operator delete(void *mem) noexcept { free(mem); }
```

## malloc

### 1. 原理

malloc（全称 memory allocation）是 C 标准库`<stdlib.h>`中的函数，用于在内存的动态存储区中分配所需的连续内存空间，分配成功时返回一个指向该内存空间的指针（此存储区中的初始值不确定），分配失败返回空指针 NULL。

```c
// size: 需要分配的内存块大小, 单位为字节
// 返回一个指向已分配内存的指针, 如果失败则返回 NULL
void *malloc(size_t size);
```

一般 malloc 函数都需要和 free 函数配对使用，后者用于释放申请的动态内存，如果在使用完后没有及时释放会造成内存泄漏。

### 2. 工作机制

操作系统存在一个记录空闲内存地址的链表，调用 malloc 函数时它会沿着空闲链表找到第一个大于所申请空间的节点，然后将该节点从空闲链表中删除，并将该节点的空间分配给程序。由于找到的节点大小不一定正好等于用户申请内存的大小，因此系统会自动将多余的部分重新放到空闲链表中。

当我们调用 free 函数时，它会将用户释放的内存块添加到空闲链表中，因此如果我们频繁调用 malloc 和 free 函数，空闲链表会被切分成很多的小内存节点。**此时如果用户申请一个比较大的内存空间时，malloc 函数在空闲链表中找不到合适大小的节点，会检查空闲链表中的各个内存片段并将相邻的小内存块合并成较大的内存块。**如果最终找不到符合要求的内存块，malloc 函数就会返回 NULL 指针，因此使用 malloc 函数时必须进行返回值的判断。

## new 与 malloc 区别

| 区别     | new                                                          | malloc                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 属性     | 既是 C++中的运算符，也是 C++中的`operator new`函数，需要编译器支持 | C/C++ 库函数，需要头文件支持                                 |
| 参数     | 使用 new 操作符申请内存分配时不需要指定内存块的大小，编译器会根据类型信息自行计算 | malloc 需要显式指出所需内存的大小                            |
| 返回类型 | new 操作符分配内存成功时返回对象类型指针，无须进行类型转换，因此 new 是符合类型安全的操作符 | malloc 内存分配成功返回`void *`，需要通过强制类型转换将`void *`指针转换成我们需要的指针类型 |
| 分配失败 | new 操作符分配失败时抛出`bad_alloc`异常                      | malloc 分配内存失败时返回 NULL 空指针                         |
| 实现机制 | new 会先调用 operator new 函数申请足够的内存（底层通常用 malloc 实现），然后调用构造函数，最后返回该类型的指针；delete 先调用析构函数，然后调用 operator delete 函数释放内存（底层通常使用 free 实现） | malloc/free 都是库函数，只能动态地申请和释放内存，具体的实现机制参照上文 |
| 重载     | C++允许重载 operator new/delete 函数，可以改变内存分配/释放的机制 | 不允许重载                                                   |
| 内存区域 | new 操作符从自由存储区（free store）上为对象动态分配内存     | malloc 从堆上为对象动态分配内存                              |

## 自由存储区与堆的区别

很多编译器的`new`和`delete`都是通过`malloc`和`free`来实现的，那么有一个问题：以`malloc`实现的`new`，所申请的内存是在堆上还是在自由存储区上？

* 堆：C 语言和操作系统的术语，指的是操作系统维护的一块提供动态分配功能的特殊内存（可以通过`malloc`和`free`来动态地申请和释放内存）
* 自由存储区：C++ 的术语，指的是通过`new`和`delete`动态分配和释放内存的内存区域

C++ 编译器默认使用堆来实现自由存储，即缺省的全局运算符`new`和`delete`是通过`malloc`和`free`来实现的。这时候以`malloc`实现的`new`既可以说是在堆上也可以说在自由存储区上（前者是具象的概念，后者是抽象的概念）。不过程序员可以通过重载`new`操作符来使用其他内存实现自由存储，此时自由存储区和堆就不是同一个概念了。

## Reference

[1] <https://www.runoob.com/cprogramming/c-function-malloc.html>

[2] <https://blog.csdn.net/nie19940803/article/details/76358673>
