# 三/五法则

## 三种/五种拷贝控制操作

C++ 语言中关于类包含五种拷贝控制操作（其中移动构造函数和移动赋值运算符是 C++11 新标准加入的）：

* 拷贝构造函数
* 拷贝赋值运算符
* 移动构造函数
* 移动赋值运算符
* 析构函数

## 三/五法则

C++ 语言并不要求我们定义全部五种拷贝控制操作：可以只定义其中一个或两个，而不必定义所有。但是这些操作通常应该被看做一个整体，只需要其中一个操作而不需要定义所有操作的情况是很少见的。

* “三法则”：针对的是较旧的 C++89 标准，指的是自定义析构函数的类不可使用合成拷贝构函数和合成拷贝赋值运算符，必须自定义拷贝和赋值操作（哪怕是删除的）
* “五法则”针对的是较新的 C++11 标准，加入了移动构造函数和移动赋值运算符，虽然不提供移动构造函数和移动赋值运算符通常不是错误，但会失去优化的机会

### 1. 自定义析构函数的类也需要自定义拷贝和赋值操作

> Tips：如果一个类需要自定义析构函数，我们几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符。一个类需要自定义析构函数往往是因为合成析构函数不足以释放类所拥有的资源（最典型的就是指针成员），自定义拷贝构造函数和拷贝赋值运算符是为了防止指针类型成员的浅拷贝问题。

假设一个类 `HasPtr` 在构造函数中分配动态内存，那么我们必须自定义一个析构函数来释放构造函数分配的内存（合成的析构函数不会 `delete` 一个指针数据成员），此时使用合成版本的拷贝构造函数和拷贝运算符会引入一个严重的错误：拷贝操作简单拷贝指针成员，这意味着多个 `HasPtr` 对象可能指向相同的内存。

```c++
#include <iostream>
#include <string>

class HasPtr {
 public:
    // 构造函数: 分配一个 string 的动态内存
    explicit HasPtr(const std::string &s) : ps_(new std::string(s)) { }
    // 自定义析构函数: 释放管理的 string 动态内存
    ~HasPtr() { delete ps_; }

 private:
    std::string *ps_;
};

int main(void) {
    HasPtr hp1 = HasPtr("tomocat");
    // hp2 调用默认的拷贝构造函数: 简单拷贝 ps_指针的值, 从而 hp1 和 hp2 的 ps_指针指向同一块内存
    HasPtr hp2 = hp1;

    // main 函数结束时调用 hp1 和 hp2 的析构函数, 导致此指针被 delete 两次, 这是未定义的行为
    // 在我的 Linux 机器上发生了 core dumped
}
```

### 2. 需要自定义拷贝操作的类也需要自定义赋值操作

有一些类只需要自定义拷贝或赋值操作，而不需要自定义析构函数。假设某个类需要拷贝构造函数为每个对象分配一个独一无二的序号，除此之外这个拷贝构造函数从给定对象拷贝所有其他数据成员。我们可以肯定的是这个类还需要自定义拷贝赋值运算符来避免将序号赋予目的对象。
