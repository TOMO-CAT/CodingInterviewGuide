# 移动构造函数和移动赋值运算符

## 1. 简介

新标准一个最主要的特性是可以移动而非拷贝对象的能力，在很多情况下对象拷贝后就立即被销毁了，在这些情况下移动而非拷贝对象会大幅度提升性能。使用移动而非拷贝的另一个原因源于 `IO` 类或 `unique_ptr` 这样的类，这些类都包含不能被共享的资源（如指针或 `IO` 缓冲），因此这些类型的对象不能拷贝但可以移动。

## 2. 移动操作: 移动构造函数与移动赋值运算符

```c++
class HasPtr {
 public:
    explicit HasPtr(const std::string &s) : ps_(new std::string(s)) { }
    HasPtr(const HasPtr &p) : ps_(new std::string(*p.ps_)) { }
    HasPtr& operator=(const HasPtr &);
    ~HasPtr() { delete ps_; }

    // 移动构造函数
    HasPtr(HasPtr&&) noexcept;
    // 移动赋值运算符
    HasPtr& operator=(HasPtr &&) noexcept;


 private:
    std::string *ps_;
};

// 移动构造函数:
// 1) 接管右侧运算对象中的资源
// 2) 令右侧运算对象进入析构安全的状态
HasPtr::HasPtr(HasPtr&& rhs) noexcept : ps_(rhs.ps_ ) {
    // 将rhs置于可析构的状态
    rhs.ps_ = nullptr;
}

// 移动赋值运算符:
// 1) 必须正确处理自赋值
// 2) 释放左侧运算对象的资源
// 3) 接管右侧运算对象中的资源
// 4) 令右侧运算对象进入析构安全的状态
HasPtr& HasPtr::operator=(HasPtr&& rhs) noexcept {
    // 直接检测自赋值
    if (this != &rhs) {
        delete ps_;
        ps_ = rhs.ps_;
        // 将rhs置于可析构的状态
        rhs.ps_ = nullptr;
    }
    return *this;
}
```

## 3. noexcept: 承诺移动操作不抛出异常

由于移动操作通常是“窃取”资源而不分配资源，因此移动操作不会抛出任何异常。当编写不抛出异常的移动构造函数和移动赋值运算符时，我们必须在类头文件的声明和定义中都指定为 `noexcept` 来通知标准库我们的移动操作不会抛出异常，防止标准库为了处理抛出异常的可能性而做一些浪费性能的额外工作。

比如标准库 `vector` 承诺如果我们调用 `push_back()` 时发生异常，则 `vector` 自身不会发生改变。假设 `push_back()` 时触发了 `vector` 扩容，此时 `vector` 会将元素从旧的堆空间复制到新申请的堆空间，考虑移动构造函数和拷贝构造函数：

* 移动构造函数：假设移动构造函数未声明成 `noexcept` 的且移动部分而非全部元素后抛出了异常，此时使用旧空间中移后源对象的值是不安全的而新空间中未构造的元素还不存在，这种情况下不能满足 `vector` 自身不变的要求
* 拷贝构造函数：假设 `vector` 使用拷贝构造函数且在拷贝部分元素后发生了异常，虽然新空间中未构造的元素还不存在但旧空间的元素保持不变，`vector` 可以释放新分配（但还未成功构造的）内存并返回

> Tips：为了避免潜在的问题，诸如 `push_back()` 等的标准库函数除非知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存拷贝元素的过程中，它就必须使用拷贝构造函数而不是移动构造函数（这会造成一定的性能浪费）。如果希望在这些情况下对我们自定义类型对象进行移动而不是拷贝，就必须显式通过 `noexcept` 声明告诉标准库我们的移动构造函数是异常安全的。

## 4. 移后源对象处于可析构但有效的状态

> Tips：在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。

从一个对象移动数据并不会销毁此对象，但是必须确保移后源对象进入一个析构安全且有效的状态：

* 析构安全：移动操作会“窃取”移后源对象的资源，析构移后源对象不应该影响其他对象数据的安全性
* 有效：**移动操作必须确保移后源对象仍然是有效的（即我们可以安全地为其赋予新值或者安全地使用而不依赖当前值）**，需要注意的是移动操作对移后源对象中留下的值没有任何要求（移后源对象的旧值是不明确的）

## 5. 合成的移动操作

只有当一个没有自定义它任何版本的拷贝构造函数（拷贝构造函数、拷贝赋值运算符或析构函数三者之一）。且类的每个非 `static` 数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。

## 6. 移动操作与拷贝操作

如果一个类既提供移动操作（移动构造函数和移动赋值运算符）也提供拷贝操作（拷贝构造函数和拷贝赋值运算符），那么对于拷贝操作而言，它接受 `const` 引用从而可以用于任何类型的实参。对于移动操作而言，它接受右值引用从而只能用于实参是非 `static` 右值的情形。

我们需要注意：

* 同时提供移动操作和拷贝操作：根据精确匹配的原则，当接受右值引用时会使用移动操作而不是拷贝操作
* 只提供拷贝操作：即使接受右值引用也会调用拷贝操作
