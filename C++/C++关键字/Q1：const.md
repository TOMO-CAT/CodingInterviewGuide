# const

## 阐述一下什么叫做顶层 const 和底层 const

指针本身是一个对象，它又可以指向另一个对象。因此指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。顶层`const`表示指针本身是一个常量，底层`const`表示指针所指的对象是不是一个常量。

## const 常量和宏定义常量的区别

Reference：<https://www.runoob.com/note/12963>

> 总结：
>
> * define 无类型，在预处理阶段展开；const 有具体类型，在编译阶段做严格的类型检查
> * define 不会分配内存，存储在程序的代码段中；const 常量需要进行内存分配，存储在程序的数据段中
> * difine 定义常量的有显著的缺点：不做类型检查，没有作用域限制（容易被后续污染）。相反地，const 常量有作用域区分（避免变量名冲突）和类型一致的安全性检测，在项目开发中更加安全方便
> * C++原则：尽量使用`const`、`enum`和`inline`替换`#define`的使用，防止编译错误不够明朗

C++可以用 const 定义常量，也可以用#define 定义常量。两者的区别在于：

### 1. 类型和安全检查不同

* define 宏定义没有类型，不做任何类型检查，仅仅是在预处理阶段展开
* const 常量有具体的类型，在编译阶段会执行严格的类型检查

### 2. 编译器处理不同

* define 宏定义是“编译时”概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束于编译时期
* const 常量是一个“运行时”概念，在程序运行时使用

### 3. 存储方式不同

* define 宏定义是预处理阶段直接替换，不会分配内存，存储在程序的代码段中
* const 常量需要进行内存分配，存储在程序的数据段中

### 4. 定义域不同

```c++
void f1 ()
{
    #define N 12
    const int n 12;
}
void f2 ()
{
    cout<<N <<endl; //正确，N 已经定义过，不受定义域限制
    cout<<n <<endl; //错误，n 定义域只在 f1 函数中
}
```

### 5. 定义后是否能取消

* define 宏常量可以通过`#undef`来使之前定义的宏常量失效
* const 常量定义后将在定义域内永久有效

### 6. 是否可以做函数参数

* 宏定义不能作为参数传递给函数
* const 常量可以在函数的参数列表中出现

### 7. 总结：define 定义常量的缺点（为什么尽量使用 const 常量替代 define 宏常量）

宏替换定义常量存在如下缺陷：

* 不做类型检查
* 没有作用域限制

由于宏定义常量相当于全局常量，很容易出现出乎意料的替换。虽然宏定义常量基本上使用全大写的特殊格式，和普通变量区分开来，但依然没解决它的的全局性问题。

## const 必须初始化吗

`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化。

## 如何定义类内 const 常量

有时我们希望定义某些常量只在类中生效，由于`#define`定义的宏常量是全局的，于是理所应当想到用 const 修饰数据成员来实现。

### 1. 不能在类声明中初始化 const 数据成员

下面的用法是错误的，不能在类声明中初始化 const 数据成员，因为类的对象未被创建时，编译器不知道 SIZE 的值是什么。

```c++
class A
{
    const int SIZE = 100;  // 错误, 企图在类声明中初始化 const 数据成员
    int array[SIZE];       // 错误, 未知的 size
}
```

### 2. const 数据成员只能在类构造函数的初始化列表中进行

```c++
class A
{
    A(int size);       // 构造函数
    const int SIZE ;  
};

A::A(int size) : SIZE(size) {}  // 构造函数的初始化表

A a(100);  // 对象 a 的 SIZE 值为 100
A b(200);  // 对象 b 的 SIZE 值为 200
```

但是这样的含义并不是我们期望的（我们希望这是一个在类内共享的常量，这里 const 数据成员只在某个对象生存期内是常量，对整个类而言却是可变的），该类每个对象的 const 数据成员值可以不同。

### 3. 用 enum 创建类内常量

```c++
class A

{
    enum { SIZE1 = 100, SIZE2 = 200}; //枚举常量 
  int array1[SIZE1];
  int array2[SIZE2];
};
```

枚举常量不会占用对象的存储空间，它们在编译期间会被全部求值。缺点是：它的隐含数据类型是整数，其最大值有限并且不能表示浮点数。

## C++内 const 的作用域

C++内 const 默认为内部连接（C 中 const 默认外部链接）。当 C 语言两个文件中都有`const int a`编译器会报重复定义的错误，而在 C++中不会。如果想让 C++中的 const 具有外部连接，必须显示声明为：

```c++
extern const int a = 10;
```

## const 作用

* const 修饰成员变量：表示不可修改的常量成员
* const 修饰成员函数：承诺在本函数内不会修改类内数据成员，不会调用其他的非 const 成员函数
* 如果 const 成员函数构成重载，那么 const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数
* const 函数只能调用 const 函数，非 const 函数可以调用 const 函数
* 类外定义的 const 成员函数，在定义和声明处都需要 const 修饰符

## Reference

[1] <https://zhuanlan.zhihu.com/p/59097334>
