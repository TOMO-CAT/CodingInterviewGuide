# 宏相关问题

## 宏常量与宏函数

C++ 中用 `#define <宏名> <字符串>` 命令定义宏，在代码中将字符串替换宏名出现的位置。定义宏的方式根据是否包含参数可以分为两种：

```c++
#define <宏名> <字符串>
#define PI 3.1415926

#define <宏名>(<参数列表>) <宏体>
#define A(x) x
```

## 使用宏的原因

### 1. 常见原因

在预处理阶段的宏替换仅仅是将目标字符串替换宏名，在代码中对宏的使用必须极其谨慎，否则很容易写出有问题的程序。定义宏的主要有如下几个场景：

* 通过宏定义常量：在常量变更时仅需要修改宏的定义而不需要修改所有使用到常量的位置
* 带参数的宏可以减少系统调用函数的开销：对于一些特别简单的函数而言，函数的调用开销不可忽视，带参数的宏在预处理阶段就进行了宏展开，提高了程序的运行效率
* 带参数的宏可以实现模板功能

### 2. 日志库获取行信息

通过宏可以获取打印日志该行的文件、行号和函数等行信息，便于 debug：

```c++
#define log_info(log_fmt, log_arg...) \
    do { \
        log4cpp_helper::Logger::getInstance()->log(log4cpp::Priority::PriorityLevel::INFO, "[%s:%d][%s] " log_fmt, \
                                                  __FILE__, __LINE__, __FUNCTION__, ##log_arg); \
    } while (0)
```

## C++ 是否应该避免使用宏，如何避免使用宏？

> Effective C++：尽量使用 `const`、`enum` 和 `inline` 替换 `#define` 的使用，防止编译错误不够明朗，同时加强编译期间的类型检查，提高代码健壮性和可读性。即尽量以编译器替换预处理器。

### 1. 使用 const 替换 #define 定义常量

程序编译分为预处理、编译和链接三个阶段。`#define` 是不被视为语言的一部分，在预处理阶段就会进行宏展开替换所有的宏，因此进入第二步编译阶段是如果遇到了编译错误，那么错误信息可能会提到 `3.14` 而不是 `PI` ，导致错误信息不够明朗。

```c++
// 不推荐
#define PI 3.14

// 推荐
const doule Pi = 3.14;
```

宏定义的记号名称 `PI` 在编译器开始处理源码之前就被预处理器移走了，于是记号名称 `PI` 有可能没进入记号表（symbol table）内。当你运用此常量但获得一个编译器错误信息时，可能会带来困惑，因为这个错误信息也许会提到 `3.14` 而非 `PI`。与此相反，double 变量 `Pi` 肯定会被编译器看到，自然就会进入记号表内。

此外，使用常量可能比使用 `#define` 导致较小量的码，因为预处理器盲目地将宏名称 `PI` 替换为 `3.14` 可能导致目标码（object code）出现多份 `3.14`，若使用常量绝不会出现这个问题。

### 2. 使用 enum 替换 #define

我们无法使用 `#define` 创建一个 class 专属常量，因为 `#define` 并不重视作用域。

对于 class 内定义常量，我们通常使用 `static` + `const` 的方式定义：

```c++
class Student {
 private:
    static const int num = 10;
    int scores[num];
};

const int Student::num;  // static 成员变量，需要进行声明
```

如果不想外部获取到 `class` 专属常量的内存地址，可以使用 `enum` 的方式定义常量（因为取一个 `enum` 的地址是不合法的）：

```c++
class Student {
 private:
    enum { num = 10 };
    int scores[num];
};
```

### 3. 使用 inline 替换 #define

> 通常使用宏定义函数主要是出于如下考虑：
>
> * 实现模板功能
> * 减少函数调用带来的开销

另外一个常见的 `#define` 误用情况是以它实现宏函数，它不会招致函数调用带来的开销，但是用 `#define` 编写宏函数容易出错，如下用宏定义写的求最大值的函数：

```c++
#define MAX(a, b) ( { (a) > (b) ? (a) : (b); } ) // 求最大值
```

这般长相的宏有着太的缺点，比如在下面调用例子：

```c++
int a = 6, b = 5;
int max = MAX(a++, b);

std::cout << max << std::endl;
std::cout << a << std::endl;
```

输出结果（以下结果是错误的）：

```c++
7 // 正确的答案是 max 输出 6
8 // 正确的答案是  a  输出 7
```

要解释出错的原因很简单，我们把 `MAX` 宏做简单替换：

```cpp
int max = ( { (a++) > (b) ? (a++) : (b); } );  // a 被累加了 2 次！
```

在上述替换后，可以发现 a 被累加了 2 次。我们可以通过改进 `MAX` 宏，来解决这个问题：

```c++
#define MAX(a, b) ({ \
    __typeof(a) __a = (a), __b = (b); \
    __a > __b ? __a : __b; \
})
```

简单说明下，上述的 `__typeof` 可以根据变量的类型来定义一个相同类型的变量。改进后的 `MAX` 宏，输出的是正确的结果，`max` 输出 6，`a` 输出 7。

虽然改进的后 `MAX` 宏，解决了问题，但是这种宏的长相就让人困惑。我们可以用 `template inline` 的方式，写出短小的函数：

```c++
template<typename T>
inline T max(const T& a, const T& b)
{
    return a > b? a : b;
}
```